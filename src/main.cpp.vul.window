#include "taskset_loader.h"
#include "taskset.h"
#include "dag_task.h"
#include "threat_analyzer.h"
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <stdexcept>
#include <iomanip>
#include <random>
#include <numeric>
#include <cmath>
#include <map>
#include <set>
#include <omp.h>

// Helper to convert string to AttackType enum and detect special modes
// Note: For this specific experiment, we don't need to parse attack type from args,
// but we keep the function for completeness of the file.
DagParser::AttackType stringToAttackType(const std::string& s,
                                         bool& is_entropy_only_mode,
                                         bool& is_targeted_entropy_mode) {
    std::string upper_s = s;
    for (char &c : upper_s) c = toupper(c);

    is_entropy_only_mode = false;
    is_targeted_entropy_mode = false;

    if (upper_s == "ANTERIOR") return DagParser::AttackType::ANTERIOR;
    if (upper_s == "POSTERIOR") return DagParser::AttackType::POSTERIOR;
    if (upper_s == "PINCER_SINGLE") return DagParser::AttackType::PINCER_SINGLE_WINDOW;
    if (upper_s == "PINCER_DUAL") return DagParser::AttackType::PINCER_DUAL_WINDOW;
    if (upper_s == "CONCURRENT") return DagParser::AttackType::CONCURRENT;
    if (upper_s == "NONE") return DagParser::AttackType::NONE;
    if (upper_s == "ALL_RELEVANT") return static_cast<DagParser::AttackType>(-1);
    if (upper_s == "ENTROPY_ONLY") {
        is_entropy_only_mode = true;
        return DagParser::AttackType::NONE;
    }
    if (upper_s == "TARGETED_ENTROPY") {
        is_targeted_entropy_mode = true;
        is_entropy_only_mode = true;
        return DagParser::AttackType::NONE;
    }
    throw std::invalid_argument("Unknown AttackType or Mode string: " + s);
}

std::string attackTypeToString(DagParser::AttackType at) {
    switch (at) {
        case DagParser::AttackType::ANTERIOR: return "ANTERIOR";
        case DagParser::AttackType::POSTERIOR: return "POSTERIOR";
        case DagParser::AttackType::PINCER_SINGLE_WINDOW: return "PINCER_SINGLE";
        case DagParser::AttackType::PINCER_DUAL_WINDOW: return "PINCER_DUAL";
        case DagParser::AttackType::CONCURRENT: return "CONCURRENT";
        case DagParser::AttackType::NONE: return "NONE";
        default: return "UNKNOWN_ATTACK_TYPE";
    }
}


int main(int argc, char* argv[]) {
    // --- Argument Handling for this specific experiment ---
    if (argc < 6) {
        std::cerr << "Usage for Window Size Test: " << argv[0]
                  << " <taskset_dir> <num_cores|-1> <vp_count> <ap_count> <num_macro_runs> [num_sim_runs_per_TH] [output_csv_file]"
                  << std::endl;
        std::cerr << "  This will sweep vulnerable window size from 10% to 100%." << std::endl;
        std::cerr << "Example: " << argv[0] << " ../dags/taskset_0 8 5 2 100 1000 results_window_sweep.csv" << std::endl;
        return 1;
    }
    std::string taskset_dir = argv[1];
    int num_cores_arg = 0;
    int vp_count_arg = 0;
    int ap_count_arg = 0;
    int num_macro_runs = 0;
    int num_sim_runs_per_TH = 1000;
    std::string output_csv_filepath;
    bool auto_sweep_m = false;

    try {
        num_cores_arg = std::stoi(argv[2]);
        vp_count_arg = std::stoi(argv[3]);
        ap_count_arg = std::stoi(argv[4]);
        num_macro_runs = std::stoi(argv[5]);

        if (num_cores_arg == -1) {
            auto_sweep_m = true;
        } else if (num_cores_arg <= 0) {
            throw std::invalid_argument("num_cores must be positive or -1 for auto-sweep.");
        }

        if (argc > 6) num_sim_runs_per_TH = std::stoi(argv[6]);
        if (argc > 7) output_csv_filepath = argv[7];

        if (vp_count_arg < 0 || ap_count_arg < 0 || num_macro_runs <= 0 || num_sim_runs_per_TH <= 0) {
            throw std::invalid_argument("Invalid numeric argument value for counts or runs.");
        }
    } catch (const std::exception& e) {
        std::cerr << "Error parsing arguments: " << e.what() << std::endl;
        return 1;
    }

    // --- Loading ---
    DagParser::TaskSetLoader loader;
    DagParser::TaskSet loaded_taskset;
    std::cout << "Attempting to load taskset from: " << taskset_dir << std::endl;
    bool load_success = false;
    try { load_success = loader.load(taskset_dir, loaded_taskset); }
    catch (const std::exception& e) { std::cerr << "Load error: " << e.what() << std::endl; return 1; }
    if (!load_success || loaded_taskset.tasks.empty() || loaded_taskset.tasks.size() != 1) {
         std::cerr << "\nFailed to load, taskset empty, or not exactly one DAG." << std::endl; return 1;
    }
    std::cout << "\nSuccessfully loaded taskset with 1 DAG." << std::endl;

    // --- Prepare for Analysis ---
    DagThreat::ThreatAnalyzer analyzer;
    std::mt19937 global_rng(std::random_device{}());
    DagParser::DAGTask base_original_dag_mutable_copy = loaded_taskset.tasks[0];
    int total_subtasks_in_dag = base_original_dag_mutable_copy.nodes.size();

    if (total_subtasks_in_dag == 0) { std::cout << "Loaded DAG has no subtasks. Exiting." << std::endl; return 0; }
    if (vp_count_arg > total_subtasks_in_dag || ap_count_arg > total_subtasks_in_dag) {
        std::cerr << "Error: Specified vp_count or ap_count exceeds total subtasks in DAG ("
                  << total_subtasks_in_dag << ")." << std::endl;
        return 1;
    }

    // --- CSV Output Setup ---
    std::ofstream csv_file;
    if (!output_csv_filepath.empty()) {
        csv_file.open(output_csv_filepath, std::ios::out);
        if (!csv_file.is_open()) {
            std::cerr << "Error: Could not open CSV output file: " << output_csv_filepath << std::endl;
            output_csv_filepath.clear();
        } else {
            // New CSV Header for this experiment
            csv_file << "Vulnerable_Window_Pct,Attack_Type,Cores_M,"
                     << "Avg_TH_Original,Successful_Runs_Orig,"
                     << "Avg_TH_Augmented,Successful_Runs_Aug" << std::endl;
            std::cout << "Logging results to CSV: " << output_csv_filepath << std::endl;
        }
    }

    // --- Define parameters for this specific experiment ---
    std::vector<DagParser::AttackType> attack_types_to_run_list = {
        DagParser::AttackType::ANTERIOR, DagParser::AttackType::POSTERIOR,
        DagParser::AttackType::PINCER_DUAL_WINDOW, DagParser::AttackType::CONCURRENT
    };
    double attacker_exec_pct_fixed = 0.10; // Fixed at 10% as per instruction
    double tp_fixed = 0.05; // Use a fixed threat probability threshold

    // --- Determine m (cores) iteration range ---
    std::vector<int> m_values_to_iterate;
    if (auto_sweep_m) {
        DagParser::DAGTask temp_dag_for_m_calc = base_original_dag_mutable_copy;
        temp_dag_for_m_calc.get_volume(); temp_dag_for_m_calc.get_critical_path_length();
        int m_min_graham = temp_dag_for_m_calc.get_min_cores_graham_bound();
        if (m_min_graham == -1) { std::cerr << "Error: DAG unschedulable by Graham's bound. Cannot auto-sweep m." << std::endl; return 1;}
        if (m_min_graham == 0) m_min_graham = 1;
        int m_max_graham_sweep = 2 * m_min_graham;
        std::cout << "Auto-sweeping num_cores (m) from " << m_min_graham << " to " << m_max_graham_sweep << std::endl;
        for (int cm = m_min_graham; cm <= m_max_graham_sweep; ++cm) if (cm > 0) m_values_to_iterate.push_back(cm);
        if (m_values_to_iterate.empty()){ std::cerr << "Error: No valid m values for auto-sweep." << std::endl; return 1;}
    } else {
        m_values_to_iterate.push_back(num_cores_arg);
    }

    // --- New Outermost Loop: Vulnerable Window Percentage ---
    for (int pct = 10; pct <= 100; pct += 10) {
        double current_vulnerable_window_pct = static_cast<double>(pct) / 100.0;
        std::cout << "\n\n####################################################################" << std::endl;
        std::cout << "Evaluating for Vulnerable Window Size = " << pct << "%" << std::endl;
        std::cout << "####################################################################" << std::endl;

        for (int current_m_for_analysis : m_values_to_iterate) {
            for (DagParser::AttackType current_attack_type : attack_types_to_run_list) {
                std::cout << "\n<<<<<<<<<< m = " << current_m_for_analysis
                          << ", Attack Type: " << attackTypeToString(current_attack_type) << " >>>>>>>>>>" << std::endl;

                std::vector<double> th_originals_for_combo;
                std::vector<double> th_augmenteds_for_combo;
                th_originals_for_combo.reserve(num_macro_runs);
                th_augmenteds_for_combo.reserve(num_macro_runs);

                // --- Loop for Macro Runs (Parallelized) ---
                #pragma omp parallel
                {
                    DagParser::DAGTask thread_local_dag_copy;
                    DagParser::TaskSet thread_local_taskset;
                    std::mt19937 thread_local_rng(std::random_device{}() + omp_get_thread_num());

                    #pragma omp for
                    for (int macro_run = 0; macro_run < num_macro_runs; ++macro_run) {
                        thread_local_dag_copy = base_original_dag_mutable_copy;
                        thread_local_taskset.tasks.clear();
                        thread_local_taskset.tasks.push_back(thread_local_dag_copy);

                        double res_orig = -1.0, res_aug = -1.0;
                        try {
                            unsigned int th_calc_seed = thread_local_rng();
                            DagThreat::ThreatAnalysisResult results = analyzer.calculate_comparative_TH(
                                    thread_local_taskset,
                                    vp_count_arg,
                                    ap_count_arg,
                                    tp_fixed,
                                    current_attack_type,
                                    current_m_for_analysis,
                                    current_vulnerable_window_pct,
                                    attacker_exec_pct_fixed,
                                    num_sim_runs_per_TH,
                                    th_calc_seed
                                    );
                            res_orig = results.th_original_dag;
                            res_aug = results.th_augmented_dag;
                        } catch (const std::exception& e) {
                            #pragma omp critical
                            { std::cerr << "  Error in (Thread " << omp_get_thread_num() << ", Macro Run " << macro_run + 1 << "): " << e.what() << std::endl; }
                        }
                        #pragma omp critical
                        {
                            th_originals_for_combo.push_back(res_orig);
                            th_augmenteds_for_combo.push_back(res_aug);
                        }
                    }
                } // End Parallel Region

                // --- Aggregate and Print/Save Results ---
                double avg_th_orig = 0.0; int count_orig = 0;
                for (double val : th_originals_for_combo) if (val >= 0.0) { avg_th_orig += val; count_orig++; }
                if (count_orig > 0) avg_th_orig /= count_orig; else avg_th_orig = -1.0;

                double avg_th_aug = 0.0; int count_aug = 0;
                for (double val : th_augmenteds_for_combo) if (val >= 0.0) { avg_th_aug += val; count_aug++; }
                if (count_aug > 0) avg_th_aug /= count_aug; else avg_th_aug = -1.0;

                std::cout << "  Aggregated Results: "
                          << "TH_orig = " << std::fixed << std::setprecision(6) << avg_th_orig
                          << ", TH_aug = " << avg_th_aug << std::endl;

                if (csv_file.is_open()) {
                    csv_file << current_vulnerable_window_pct << ","
                             << attackTypeToString(current_attack_type) << ","
                             << current_m_for_analysis << ","
                             << std::fixed << std::setprecision(8)
                             << (count_orig > 0 ? avg_th_orig : -1.0) << "," << count_orig << ","
                             << (count_aug > 0 ? avg_th_aug : -1.0) << "," << count_aug
                             << std::endl;
                }
            }
        }
    } // End Vulnerable Window Percentage Loop

    if (csv_file.is_open()) {
        csv_file.close();
        std::cout << "\nResults also written to: " << output_csv_filepath << std::endl;
    }

    std::cout << "\nAll tests finished." << std::endl;
    return 0;
}
